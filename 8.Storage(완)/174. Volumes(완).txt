------------------------------------------------------------------
[pod-definition.yaml]
apiVersion: v1
kind: Pod
metadata:
	name: randome-number-generator
spec:
	containers:
	-  image: alphine
		name: alphine
		command: ["/bin/sh", "-c"]
		args: ["shuf -i 0-100 -n 1 >> /opt/number.out/"]
		volumeMounts:		<-- 볼륨 마운팅:컨테이너에 부착
		- mountPath: /opt
		  name: data-volume
		
	volumes:		<-- 바인드 마운팅
	- name: data-volume
	  hostPath:
		path: /data
		type: Directory
------------------------------------------------------------------


Hello and welcome to this lecture on Persistent Volumes in Kubernetes.
안녕하세요 이번 강의에서는 영구 볼륨에 대해 알아 보게씁니다.

My name is Mumshad Mannambeth. 

Before we head into persistent volumes
영구 볼륨으로 진입 하기 전에.

let us start with Volumes in Kubernetes. 
쿠버네티스에 볼륨부터 시작해 보겠습니다.

Let us look at volumes in Docker first. 
여기 도커 내 볼륨을 봅시다.

Docker containers are meant to be transient in nature which means they are meant to last only for a short period of time.
도커 컨테이너는 본질적으로 짧은 기간 동안에만 남아 있는 다는 의미입니다.

They are called upon when required to process data and destroyed once finished.
도커 컨테이너는 데이터 처리 요청이 있는 동안 불려 집니다. 그리고 해당 작업이 종료되면 파괴됩니다.

The same is true for the data within the container 
컨테이너내 데이터도 마찬가지입니다.

the data is destroyed along with the container 
데이터는 컨테이너와 함께 파괴됩니다.

to persist data processed by the containers we attach a volume to the containers when they are created.
우리가 컨테이너가 생성될때 볼륨을 추가한 컨테이너에 의해 영구적인 데이터 처리는 이루어 집니다.

(thereby :그것에 의하여, 그 때문에, 따라서) (retaining:유지, 꼬리가 다시 있음) (permanently:영구적으로)
The data are processed by the container is now placed in this volume thereby retaining it permanently.
컨테이너에 의해 처리되는 데이터는 지금 이 볼륨에 있습니다. 따라서 영구적으로 유지합니다.

Even if the container is deleted the data generated or processed by it remains.
컨테이너가 삭제 되어도 생성되거나 처리된 데이터는 그대로 유지됩니다.

So how does that work in the Kubernetes world.
그럼 이 작업은 쿠버네티스 세상에서 어떻게 이루어 지는 걸까요?

Just as in Docker, the PODs created in Kubernetes are transient in nature.
도커의 경우 쿠버네티스에서 생성된 POD 는 본질적으로 일시적입니다.

When a POD is created to process data and then deleted, the data processed by it gets deleted as well.
POD 가 생성되어 데이터를 처리하거나 삭제될때, 처리된 데이터는 삭제가 됩니다.

For this we attach a volume to the POD. The data generated by the POD is now stored in the volume, 
우리가 POD에 첨부한 볼륨의 경우 POD 에 의해 생성된 데이터는 이제 볼륨에 저장됩니다.

and even after the POD is delete, the data remains. 
그리고 POD 가 삭제된다 하더라도 데이터는 남습니다.

Let’s look at a simple implementation of volumes.
볼륨에 구현된 간단한 예제를 봅시다.

We have a single node kubernetes cluster.
우리는 싱글 노드를 가지고 있습니다.

We create a simple POD that generates a random number between 1 and 100 and writes that to a file at /opt/number.out 
1~100 사이에 랜덤 숫자를 생성하고 파일에 작업하는 간단한 POD 를 생성 합니다. 파일위치는 /opt/number.out에

(along with:~와 함께)
it then gets deleted along with the random number. 
이것이 끝나면. 랜덤 넘버와 함께 삭제됩니다.

To retain the number generated by the pod.
POD에 의해 생성된 숫자가 지속하기 위해서는

We create a volume and a volume needs a storage.
볼륨을 생성하고 저장공간을 제공해야 합니다.

When you create a volume you can choose to configure it storage in different ways.
볼륨을 생성 했을떄. 다른 방법의 저장장소를 설정을 선택 할 수 있습니다.

------------------------------------------------------------------
[pod-definition.yaml]
apiVersion: v1
kind: Pod
metadata:
	name: randome-number-generator
spec:
	containers:
	-  image: alphine
		name: alphine
		command: ["/bin/sh", "-c"]
		args: ["shuf -i 0-100 -n 1 >> /opt/number.out/"]
		volumeMounts:		<-- 볼륨 마운팅:컨테이너에 부착
		- mountPath: /opt
		  name: data-volume
		
	volumes:		<-- 바인드 마운팅
	- name: data-volume
	  hostPath:
		path: /data
		type: Directory
------------------------------------------------------------------

We will look at the various options in a bit but for now we will simply configure it to use a directory on the host.
여기 다양한 옵션을 볼 수 있습니다. 하지만 지금은 우리는 간단하게 호스트에 디렉토리를 사용하도록 설정할 것입니다.

In this case I specify a path: /data on the hostPath.
이 경우 hostPath 아래에 path 를 /data로 지정 합니다.

This way any files created in the volume would be stored in the directory data on my node. 
이 방법으로 노드의 디렉토리안에 모든 파일을 볼륨 안에 생성하여 저장될수 있습니다.

Once the volume is created, to access it from a container we mount the volume to a directory inside the container.
볼륨이 생성되면, 컨테이너에서 이 볼륨에 접근 하기 위해 우리는 컨테이너 내부의 디렉토리 로 볼륨을 마운트 합니다. 

We use the volumeMounts field in each container to mount the data-volume to the directory /opt within the container.
우리는 각각의 컨테이너에 data_volume 을 마운트 하기 위해 볼륨 마운트 필드를 이용합니다. 

The random number will now be written to /opt mount inside the container, which happens to be on the data-volume which is in fact /data directory on the host.
랜덤 넘버는 이제 컨테이너내부의 /opt 폴더에 파일을 쓰게 됩니다.

When the pod gets deleted, the file with the random number still lives on the host.
POD 가 삭제되면, 랜덤 넘버 파일은 여전히 호스트에 ㄴㅁ게 됩니다.

Let's take a step back and look at the volume storage options.
이제 다시 돌아가서 볼륨 스토리지 옵션을 살펴 봅시다.

We just used the host path option to configure a directory and the host has storage space for the volume.
우리는 방금 호스트 경로 옵션을 사용했습니다. 호스트에 볼륨을 추가하여 사용하기 위한 옵션으로.

Now that works fine on a single node however it is not recommended for use in a multi node cluster.
이제 단일 노드에서 잘 작동 합니다. 하지만 이 방식은 멀티플 노드 클러스터에서는 추천 되지는 않습니다.

This is because the PODs would use the /data directory on all the nodes, and expect all of them to be the same and have the same data 
왜냐하면 POD들이 /data 디렉토리를 전체 노드에서 사용하기 때문입니다. 그리고 모두 동일한 데이터를 가질것으로 예상됩니다.

since they are on different servers. They are in fact not the same.
각각의 노드들은 서로 다른 서버이기 때문에. 그들은 사실 동일하지가 않습니다.

(unless:~하지않는한)
unless you configure some kind of external replicated cluster storage solution.
외부 복제 클러스터 스토리지 솔루션을 구성하지 않는 한.

Kubernetes supports several types of different storage solutions such as NFS, glusterFS,
쿠버네티스는 몇몇 유형의 서로 다른 스토리지 솔루션을 지원 합니다. 가량 NFS 라던가 글러스터 FS 이라던가.

Flocker, FibreChannel, CephFS, ScaleIO or public cloud solutions like AWS EBS, Azure Disk or File or Google’s Persistent Disk.
Flocker 라던가 등등

For example, to configure an AWS Elastic Block Store volume as the storage option for the volume, 
예를 들어, 스토리지 옵션으로 AWS 엘라스틱 블록 스토어 볼륨을 구성하는 것

we replace hostPath field of the volume with aws ElasticBlockStore field along with the volumeID and filesystem type. 
hostPath 필드를 awsElasticBlockStore 필드로 교제해야 합니다.

The Volume storage will now be on AWS EBS.
볼륨 스토리지가 이제 AWS EBS 가 되었습니다.

Well, that’s it about Volumes in Kubernetes. We will now head over to discuss Persistent Volumes next.